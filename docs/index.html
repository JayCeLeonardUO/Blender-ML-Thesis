<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voronoi Shader Background</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        #glcanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .button-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 20px;
        }

        .button {
            padding: 15px 30px;
            font-size: 16px;
            color: white;
            background-color: #132A13;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        .button:hover {
            background-color: #FDFCDC;
            color: #132A13;
            transform: scale(1.05);
        }

        .button:active {
            transform: scale(1);
        }

        /* Title Styles */
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            color: #000000;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .button {
                padding: 12px 25px;
                font-size: 14px;
            }

            .title {
                font-size: 24px;
            }
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div class="title">GFlowNets: Generative Modeling for Geometry Nodes</div>
    <div class="button-container">
        <a href="https://github.com/JayCeLeonardUO/Blender-ML-Thesis">
            <button class="button">Github</button>
        </a>
        <a href="https://jayceleonarduo.github.io/my-docs/">
            <button class="button">Dev-log</button>
        </a>
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        void main() {
            gl_Position = a_position;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        // Declare the uniforms
        uniform float iTime;
        uniform vec2 iResolution;

        // Hash function
        vec2 hash(vec2 p) {
            return fract(sin(vec2(dot(p, vec2(1.0, 57.0)), dot(p, vec2(53.0, 113.0)))) * (100.1517 + 0.057 * iTime));
        }

        // Color palette
        vec3 colorPallete(float t) {
            // New color palette: Light cream and blue
            vec3 col1 = vec3(253.0 / 255.0, 252.0 / 255.0, 220.0 / 255.0);  // Light cream (#FDFCDC)
            vec3 col2 = vec3(19.0 / 255.0, 42.0 / 255.0, 19.0 / 255.0);    // Dark green (#132A13)
            return t * col1 + (1.0 - t) * col2;
        }

        // Voronoi distance calculation
        vec3 voronoiDistance(in vec2 x) {
            vec2 p = vec2(floor(x));
            vec2 f = fract(x);

            vec2 mb;
            vec2 mr;
            vec2 closest;

            float res = 8.0;
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    vec2 b = vec2(i, j);
                    vec2 r = vec2(b) + hash(p + b) - f;
                    float d = dot(r, r);

                    if (d < res) {
                        res = d;
                        mr = r;
                        mb = b;
                        closest = hash(p + b) + p + f;
                    }
                }
            }

            res = 8.0;
            for (int j = -2; j <= 2; j++) {
                for (int i = -2; i <= 2; i++) {
                    vec2 b = mb + vec2(i, j);
                    vec2 r = vec2(b) + hash(p + b) - f;
                    float d = dot(0.5 * (mr + r), normalize(r - mr));

                    res = min(res, d);
                }
            }

            return vec3(res, closest);
        }

        void main() {
            // Normalized pixel coordinates (from 0 to 1)
            vec2 uv = gl_FragCoord.xy / iResolution.xy;
            float size = 10.0;
            uv *= size;

            // Voronoi distance calculation
            vec3 res = voronoiDistance(uv);
            float d = smoothstep(0.0, 0.025, res.x);
            vec2 p = res.yz / size;

            // Output to screen
            gl_FragColor = vec4(vec3(d) * colorPallete(p.y + 0.5 * (abs(p.x - 0.5))), 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            console.error('WebGL not supported');
        } else {
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(`Shader compile error: ${gl.getShaderInfoLog(shader)}`);
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertexShaderSource = document.getElementById('vertex-shader').text;
            const fragmentShaderSource = document.getElementById('fragment-shader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(`Program link error: ${gl.getProgramInfoLog(program)}`);
            } else {
                gl.useProgram(program);

                const positionLocation = gl.getAttribLocation(program, 'a_position');

                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                    -1, -1,
                    1, -1,
                    -1, 1,
                    1, 1,
                ]), gl.STATIC_DRAW);

                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                const iTimeLocation = gl.getUniformLocation(program, 'iTime');
                const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');

                function render(time) {
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    // Pass time and resolution to the shader
                    gl.uniform1f(iTimeLocation, time * 0.001); // Time in seconds
                    gl.uniform2fv(iResolutionLocation, [canvas.width, canvas.height]);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    requestAnimationFrame(render);
                }

                render(0);
            }
        }
    </script>
</body>

</html>